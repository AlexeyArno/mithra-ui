{"remainingRequest":"D:\\Snnash\\client-frontend\\node_modules\\babel-loader\\lib\\index.js!D:\\Snnash\\client-frontend\\node_modules\\loglevel\\lib\\loglevel.js","dependencies":[{"path":"D:\\Snnash\\client-frontend\\node_modules\\loglevel\\lib\\loglevel.js","mtime":1510612422000},{"path":"D:\\Snnash\\client-frontend\\.babelrc","mtime":1528721307992},{"path":"D:\\Snnash\\client-frontend\\node_modules\\cache-loader\\dist\\cjs.js","mtime":0},{"path":"D:\\Snnash\\client-frontend\\node_modules\\babel-loader\\lib\\index.js","mtime":1520329890000}],"contextDependencies":[],"result":["'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n})(undefined, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n\n    var noop = function noop() {};\n    var undefinedType = \"undefined\";\n\n    var logMethods = [\"trace\", \"debug\", \"info\", \"warn\", \"error\"];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function () {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if ((typeof console === 'undefined' ? 'undefined' : _typeof(console)) === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = i < level ? noop : this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if ((typeof console === 'undefined' ? 'undefined' : _typeof(console)) !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n        var self = this;\n        var currentLevel;\n        var storageKey = \"loglevel\";\n        if (name) {\n            storageKey += \":\" + name;\n        }\n\n        function persistLevelIfPossible(levelNum) {\n            var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n            if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === undefinedType) return;\n\n            // Use localStorage if available\n            try {\n                window.localStorage[storageKey] = levelName;\n                return;\n            } catch (ignore) {}\n\n            // Use session cookie as fallback\n            try {\n                window.document.cookie = encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n            } catch (ignore) {}\n        }\n\n        function getPersistedLevel() {\n            var storedLevel;\n\n            if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === undefinedType) return;\n\n            try {\n                storedLevel = window.localStorage[storageKey];\n            } catch (ignore) {}\n\n            // Fallback to cookies if local storage gives us nothing\n            if ((typeof storedLevel === 'undefined' ? 'undefined' : _typeof(storedLevel)) === undefinedType) {\n                try {\n                    var cookie = window.document.cookie;\n                    var location = cookie.indexOf(encodeURIComponent(storageKey) + \"=\");\n                    if (location !== -1) {\n                        storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                    }\n                } catch (ignore) {}\n            }\n\n            // If the stored level is not valid, treat it as if nothing was stored.\n            if (self.levels[storedLevel] === undefined) {\n                storedLevel = undefined;\n            }\n\n            return storedLevel;\n        }\n\n        /*\n         *\n         * Public logger API - see https://github.com/pimterry/loglevel for details\n         *\n         */\n\n        self.name = name;\n\n        self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n            \"ERROR\": 4, \"SILENT\": 5 };\n\n        self.methodFactory = factory || defaultMethodFactory;\n\n        self.getLevel = function () {\n            return currentLevel;\n        };\n\n        self.setLevel = function (level, persist) {\n            if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n                level = self.levels[level.toUpperCase()];\n            }\n            if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n                currentLevel = level;\n                if (persist !== false) {\n                    // defaults to true\n                    persistLevelIfPossible(level);\n                }\n                replaceLoggingMethods.call(self, level, name);\n                if ((typeof console === 'undefined' ? 'undefined' : _typeof(console)) === undefinedType && level < self.levels.SILENT) {\n                    return \"No console available for logging\";\n                }\n            } else {\n                throw \"log.setLevel() called with invalid level: \" + level;\n            }\n        };\n\n        self.setDefaultLevel = function (level) {\n            if (!getPersistedLevel()) {\n                self.setLevel(level, false);\n            }\n        };\n\n        self.enableAll = function (persist) {\n            self.setLevel(self.levels.TRACE, persist);\n        };\n\n        self.disableAll = function (persist) {\n            self.setLevel(self.levels.SILENT, persist);\n        };\n\n        // Initialize with the right level\n        var initialLevel = getPersistedLevel();\n        if (initialLevel == null) {\n            initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n        }\n        self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"string\" || name === \"\") {\n            throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n            logger = _loggersByName[name] = new Logger(name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== undefinedType ? window.log : undefined;\n    defaultLogger.noConflict = function () {\n        if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== undefinedType && window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    return defaultLogger;\n});",{"version":3,"sources":["node_modules\\loglevel\\lib\\loglevel.js"],"names":["root","definition","define","amd","module","exports","log","noop","undefinedType","logMethods","bindMethod","obj","methodName","method","bind","Function","prototype","call","e","apply","arguments","realMethod","console","undefined","replaceLoggingMethods","level","loggerName","i","length","methodFactory","debug","enableLoggingWhenConsoleArrives","defaultMethodFactory","Logger","name","defaultLevel","factory","self","currentLevel","storageKey","persistLevelIfPossible","levelNum","levelName","toUpperCase","window","localStorage","ignore","document","cookie","encodeURIComponent","getPersistedLevel","storedLevel","location","indexOf","exec","slice","levels","getLevel","setLevel","persist","SILENT","setDefaultLevel","enableAll","TRACE","disableAll","initialLevel","defaultLogger","_loggersByName","getLogger","TypeError","logger","_log","noConflict","getLoggers"],"mappings":"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","file":"loglevel.js","sourceRoot":"D:/Snnash/client-frontend","sourcesContent":["/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      var storageKey = \"loglevel\";\n      if (name) {\n        storageKey += \":\" + name;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"string\" || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    return defaultLogger;\n}));\n"]}]}